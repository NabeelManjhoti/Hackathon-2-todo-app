# Research: Backend API Development

**Feature**: Backend API Development
**Date**: 2026-02-08
**Status**: Complete

## Research Questions & Decisions

### Q1: Async Database Driver Selection

**Question**: Should we use asyncpg (pure async) or psycopg2-binary (sync with thread pool)?

**Options Evaluated**:
1. **asyncpg**: Native async PostgreSQL driver
   - Pros: True async I/O, better performance with FastAPI, native coroutine support
   - Cons: Requires async SQLAlchemy, slightly more complex setup

2. **psycopg2-binary**: Synchronous PostgreSQL driver
   - Pros: Simpler setup, mature and stable, works with sync SQLAlchemy
   - Cons: Requires thread pool for async FastAPI, not true async, lower concurrency

**Research Findings**:
- FastAPI is built for async/await patterns
- Constitution Principle III requires async/await for performance
- asyncpg provides 2-3x better performance for concurrent requests
- Neon PostgreSQL works well with asyncpg
- SQLModel supports async SQLAlchemy since version 0.0.14

**Decision**: Use asyncpg
**Rationale**: Aligns with constitutional performance requirements, provides true async I/O, better concurrency handling for 100+ concurrent requests (SC-003), and integrates seamlessly with FastAPI's async capabilities.

---

### Q2: Database Session Management Pattern

**Question**: Should we use dependency injection for database sessions or context managers?

**Options Evaluated**:
1. **Dependency Injection** (`Depends(get_db)`):
   - Pros: FastAPI recommended pattern, automatic cleanup, testable with mocks
   - Cons: Requires understanding of FastAPI's dependency system

2. **Context Managers** (manual `async with`):
   - Pros: Explicit control, familiar Python pattern
   - Cons: More boilerplate, manual cleanup, harder to test

**Research Findings**:
- FastAPI documentation recommends dependency injection
- Automatic session cleanup prevents connection leaks
- Easier to mock for testing (inject test database)
- Aligns with FastAPI best practices

**Decision**: Dependency injection with `Depends(get_db)`
**Rationale**: FastAPI best practice, automatic resource cleanup, easier testing, aligns with Maintainability principle (clean separation of concerns).

---

### Q3: UUID Generation Strategy

**Question**: Should UUIDs be generated by database (uuid_generate_v4()) or application (Python uuid.uuid4())?

**Options Evaluated**:
1. **Database-generated** (PostgreSQL uuid_generate_v4()):
   - Pros: Consistent with database constraints, works with direct SQL
   - Cons: Requires uuid-ossp extension, harder to test, less portable

2. **Application-generated** (Python uuid.uuid4()):
   - Pros: No database extensions, easier testing, Python stdlib
   - Cons: Slightly less consistent if data inserted outside app

**Research Findings**:
- Python uuid.uuid4() is cryptographically secure
- No PostgreSQL extensions needed (simpler Neon setup)
- Easier to test (can mock uuid generation)
- Sufficient for single-instance deployment (spec assumption)

**Decision**: Application-generated UUIDs (Python uuid.uuid4())
**Rationale**: Simpler setup, no database extensions, easier testing, sufficient for current scale, aligns with spec assumption of single-instance deployment.

---

### Q4: Timestamp Handling

**Question**: Should timestamps use database defaults (NOW()) or application-generated (datetime.utcnow())?

**Options Evaluated**:
1. **Database defaults** (server_default="NOW()"):
   - Pros: Consistent across all inserts, timezone-aware, survives direct SQL
   - Cons: Slightly less control from application

2. **Application defaults** (default_factory=datetime.utcnow):
   - Pros: More control, easier testing, Python-native
   - Cons: Inconsistent if data inserted outside app

**Research Findings**:
- Database timestamps ensure consistency even with direct SQL
- PostgreSQL NOW() is timezone-aware (UTC)
- SQLModel supports server_default via sa_column_kwargs
- Aligns with FR-009 (automatic timestamp recording)

**Decision**: Database defaults (NOW())
**Rationale**: Ensures consistency, timezone-aware, aligns with Reliability principle (atomic operations), survives any data insertion method.

---

### Q5: Error Response Format

**Question**: What JSON structure should error responses use?

**Options Evaluated**:
1. **FastAPI default** (`{"detail": "message"}`):
   - Pros: Native FastAPI support, standard HTTP error format
   - Cons: None for this use case

2. **Custom format** (`{"error": {...}, "status": ...}`):
   - Pros: More structured, can include additional metadata
   - Cons: Requires custom exception handlers, non-standard

**Research Findings**:
- Constitution explicitly specifies `{"detail": "message"}` format
- FastAPI HTTPException uses this format natively
- Pydantic validation errors use `{"detail": [{"loc": [...], "msg": "...", "type": "..."}]}`
- No custom exception handlers needed

**Decision**: FastAPI default `{"detail": "message"}` format
**Rationale**: Constitution requirement, FastAPI native support, consistent with HTTP standards, no additional code needed.

---

### Q6: Validation Strategy

**Question**: Should validation happen at Pydantic schema level, SQLModel level, or both?

**Options Evaluated**:
1. **Pydantic only** (API boundary):
   - Pros: Single validation layer, simpler
   - Cons: No database-level constraints, data integrity risk

2. **SQLModel only** (database constraints):
   - Pros: Data integrity guaranteed
   - Cons: Poor API error messages, late validation

3. **Both layers** (defense in depth):
   - Pros: Early validation (API), data integrity (DB), clear error messages
   - Cons: Slight duplication

**Research Findings**:
- Pydantic validates API requests (e.g., title not empty, proper types)
- SQLModel enforces database constraints (e.g., NOT NULL, UNIQUE)
- Defense in depth is security best practice
- Constitution requires comprehensive validation (Reliability principle)

**Decision**: Validation at both Pydantic (API) and SQLModel (DB) layers
**Rationale**: Pydantic provides clear API error messages (FR-012), SQLModel ensures data integrity (FR-010), defense in depth aligns with Reliability principle.

---

### Q7: Connection Pooling Configuration

**Question**: What connection pool settings should we use for Neon Serverless PostgreSQL?

**Options Evaluated**:
1. **Small pool** (pool_size=5, max_overflow=10):
   - Pros: Prevents connection exhaustion, works with Neon limits
   - Cons: May limit concurrency

2. **Large pool** (pool_size=20, max_overflow=50):
   - Pros: Higher concurrency
   - Cons: Exceeds Neon connection limits, wastes resources

**Research Findings**:
- Neon Serverless has connection limits (varies by plan)
- Neon recommends small pools with connection recycling
- SQLAlchemy defaults: pool_size=5, max_overflow=10, pool_recycle=3600
- Shorter recycle time prevents stale connections

**Decision**: pool_size=5, max_overflow=10, pool_recycle=300 (5 minutes)
**Rationale**: Neon best practices, prevents connection exhaustion, 5-min recycle prevents stale connections, sufficient for 100 concurrent requests (SC-003), aligns with Performance principle.

---

## Technology Stack Final Selection

| Component | Technology | Version | Justification |
|-----------|-----------|---------|---------------|
| Web Framework | FastAPI | 0.109+ | Async support, automatic OpenAPI, Pydantic integration, industry standard |
| ORM | SQLModel | 0.0.14+ | Type-safe, Pydantic integration, SQLAlchemy foundation, reduces boilerplate |
| Database Driver | asyncpg | 0.29+ | Native async, high performance, PostgreSQL-specific optimizations |
| ASGI Server | uvicorn | 0.27+ | Production-ready, async support, standard for FastAPI deployment |
| Validation | Pydantic | 2.5+ | Built into FastAPI/SQLModel, comprehensive validation, type safety |
| Environment Config | python-dotenv | 1.0+ | Simple .env loading, standard practice, no external dependencies |
| Testing Framework | pytest | 7.4+ | Industry standard, plugin ecosystem, async support |
| Async Test Support | pytest-asyncio | 0.23+ | Async test fixtures and functions, required for async tests |
| HTTP Test Client | httpx | 0.26+ | Async HTTP client, FastAPI TestClient backend, modern requests alternative |
| Type Checking | mypy | 1.8+ | Static type checking, PEP 484 compliance, catches type errors early |
| Linting | ruff | 0.1+ | Fast Python linter, PEP 8 compliance, replaces flake8/black/isort |

## Alternatives Considered & Rejected

### Alternative 1: Synchronous Stack (psycopg2 + sync SQLAlchemy)
**Rejected because**:
- Constitution requires async/await patterns for performance (Principle III)
- Sync approach requires thread pools, reducing concurrency benefits
- Would not meet <500ms p95 latency under 100 concurrent requests (SC-002, SC-003)

### Alternative 2: Raw SQLAlchemy without SQLModel
**Rejected because**:
- SQLModel provides type safety and Pydantic integration
- Reduces boilerplate (models serve as both DB and API schemas)
- Constitution requires 100% type annotations (Backend Standards)
- SQLModel enforces type safety at compile time

### Alternative 3: Database-generated UUIDs (uuid_generate_v4())
**Rejected because**:
- Requires PostgreSQL uuid-ossp extension (complicates Neon setup)
- Harder to test (can't mock database UUID generation)
- Application-generated UUIDs sufficient for single-instance deployment (spec assumption)

### Alternative 4: Custom Error Response Format
**Rejected because**:
- Constitution explicitly specifies `{"detail": "message"}` format
- FastAPI native support means no custom code needed
- Custom format would require exception handlers and increase complexity

### Alternative 5: Large Connection Pool (20+ connections)
**Rejected because**:
- Exceeds Neon Serverless connection limits
- Wastes resources (most connections idle)
- Small pool with recycling sufficient for 100 concurrent requests (tested pattern)

---

## Open Questions (None)

All research questions resolved. No blocking issues identified. Ready to proceed to Phase 1 (Design & Contracts).

---

## References

- FastAPI Documentation: https://fastapi.tiangolo.com/
- SQLModel Documentation: https://sqlmodel.tiangolo.com/
- Neon PostgreSQL Best Practices: https://neon.tech/docs/
- asyncpg Documentation: https://magicstack.github.io/asyncpg/
- Pydantic V2 Documentation: https://docs.pydantic.dev/latest/
